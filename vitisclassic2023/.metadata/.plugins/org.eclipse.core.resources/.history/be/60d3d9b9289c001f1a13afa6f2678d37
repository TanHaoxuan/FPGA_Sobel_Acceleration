#include "xparameters.h"
#include "xuartps.h"
#include <stdio.h>
#include <stdlib.h>

#include "platform.h"
#include "xtmrctr.h"
#include "xil_printf.h"
#include <string.h>
#include <stdbool.h>
#include <unistd.h>

#define MAX_IMG_HEIGHT 256
#define MAX_IMG_WIDTH 256

int InitializeUART(u16 DeviceId);
int InitializeTimer(u16 DeviceId);
void StartTimer();
u32 StopTimer();
void readImageFromUART(unsigned char img[MAX_IMG_HEIGHT][MAX_IMG_WIDTH], unsigned *height, unsigned *width);
void writeImageToUART(unsigned char img[MAX_IMG_HEIGHT][MAX_IMG_WIDTH], unsigned height, unsigned width);
void applySobelFilter(unsigned char input[MAX_IMG_HEIGHT][MAX_IMG_WIDTH], unsigned char output[MAX_IMG_HEIGHT][MAX_IMG_WIDTH], unsigned height, unsigned width);

XUartPs Uart_Ps;        /* Instance of the UART Driver */
XTmrCtr TimerInstance;  /* Instance of the Timer Driver */

int main() {
    unsigned char image[MAX_IMG_HEIGHT][MAX_IMG_WIDTH];
    unsigned char output_image[MAX_IMG_HEIGHT][MAX_IMG_WIDTH];
    unsigned height, width;

    if (InitializeUART(XPAR_XUARTPS_0_DEVICE_ID) != XST_SUCCESS) {
        xil_printf("UART Initialization Failed\r\n");
        return XST_FAILURE;
    }
    if (InitializeTimer(XPAR_TMRCTR_0_DEVICE_ID) != XST_SUCCESS) {
        xil_printf("Timer Initialization Failed\r\n");
        return XST_FAILURE;
    }

    xil_printf("Receiving Image...\r\n");
    readImageFromUART(image, &height, &width);
    xil_printf("Received Image: %u x %u\r\n", height, width);

    StartTimer();
    applySobelFilter(image, output_image, height, width);
    u32 elapsedTime = StopTimer();
    xil_printf("Finished edge detection in %u clock cycles.\r\n", elapsedTime);

    writeImageToUART(output_image, height, width);

    return 0;
}

int InitializeUART(u16 DeviceId) {
    XUartPs_Config *Config = XUartPs_LookupConfig(DeviceId);
    if (!Config) return XST_FAILURE;

    int Status = XUartPs_CfgInitialize(&Uart_Ps, Config, Config->BaseAddress);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XUartPs_SetBaudRate(&Uart_Ps, 115200);
    return XST_SUCCESS;
}

int InitializeTimer(u16 DeviceId) {
    int Status = XTmrCtr_Initialize(&TimerInstance, DeviceId);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    XTmrCtr_SetOptions(&TimerInstance, TIMER_COUNTER_0, XTC_AUTO_RELOAD_OPTION);
    return XST_SUCCESS;
}

void StartTimer() {
    XTmrCtr_Reset(&TimerInstance, TIMER_COUNTER_0);
    XTmrCtr_Start(&TimerInstance, TIMER_COUNTER_0);
}

u32 StopTimer() {
    XTmrCtr_Stop(&TimerInstance, TIMER_COUNTER_0);
    return XTmrCtr_GetValue(&TimerInstance, TIMER_COUNTER_0);
}

void readImageFromUART(unsigned char img[MAX_IMG_HEIGHT][MAX_IMG_WIDTH], unsigned *height, unsigned *width) {
    char buffer[4096];
    fgets(buffer, sizeof(buffer), stdin);  // Read dimensions
    sscanf(buffer, "%u,%u", height, width);

    for (int row = 0; row < *height; ++row) {
        fgets(buffer, sizeof(buffer), stdin);
        char *token = strtok(buffer, ",");
        for (int col = 0; col < *width; ++col) {
            img[row][col] = atoi(token);
            token = strtok(NULL, ",");
        }
    }
}

void writeImageToUART(unsigned char img[MAX_IMG_HEIGHT][MAX_IMG_WIDTH], unsigned height, unsigned width) {
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            printf("%d,", img[i][j]);
        }
        printf("\n");
    }
}

void applySobelFilter(unsigned char input[MAX_IMG_HEIGHT][MAX_IMG_WIDTH], unsigned char output[MAX_IMG_HEIGHT][MAX_IMG_WIDTH], unsigned height, unsigned width) {
    int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};
    int Gy[3][3] = {{-1, -2, -1}, {0, 0, 0}, {1, 2, 1}};
    for (int i = 1; i < height - 1; ++i) {
        for (int j = 1; j < width - 1; ++j) {
            int px = 0, py = 0;
            for (int x = -1; x <= 1; ++x) {
                for (int y = -1; y <= 1; ++y) {
                    px += input[i + x][j + y] * Gx[x + 1][y + 1];
                    py += input[i + x][j + y] * Gy[x + 1][y + 1];
                }
            }
            int magnitude = abs(px) + abs(py);
            output[i][j] = (magnitude > 255) ? 255 : magnitude;
        }
    }
}
