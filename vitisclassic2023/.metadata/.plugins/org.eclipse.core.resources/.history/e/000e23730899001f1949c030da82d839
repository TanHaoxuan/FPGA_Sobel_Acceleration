/******************************************************************************
* Copyright (C) 2023 Advanced Micro Devices, Inc. All Rights Reserved.
* SPDX-License-Identifier: MIT
******************************************************************************/
/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include "xparameters.h"
#include "xuartps.h"
#include <stdio.h>
#include <stdlib.h>

#include "platform.h"
#include "xil_printf.h"
#include <stdbool.h>
#include <unistd.h>
#include "xtmrctr.h"

/************************** Constant Definitions *****************************/

/*
 * The following constants map to the XPAR parameters created in the
 * xparameters.h file. They are defined here such that a user can easily
 * change all the needed parameters in one place.
 */
#ifndef SDT
#define UART_DEVICE_ID          XPAR_XUARTPS_0_DEVICE_ID
#else
#define	XUARTPS_BASEADDRESS		XPAR_XUARTPS_0_BASEADDR
#endif

#ifndef SDT
#define TMRCTR_DEVICE_ID	XPAR_TMRCTR_0_DEVICE_ID
#else
#define XTMRCTR_BASEADDRESS	XPAR_XTMRCTR_0_BASEADDR
#endif
/**************************** Type Definitions *******************************/

/***************** Macros (Inline Functions) Definitions *********************/

/************************** Function Prototypes ******************************/
#define IMG_WIDTH 256
#define IMG_HEIGHT 256
// Sobel Operator Kernels
int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};
int Gy[3][3] = {{-1, -2, -1}, {0, 0, 0}, {1, 2, 1}};

int InitializeUART(u16 DeviceId);
void readImage(unsigned char img[IMG_HEIGHT][IMG_WIDTH]);
void writeImage(unsigned char img[IMG_HEIGHT][IMG_WIDTH]);
void applySobelFilter(unsigned char input[IMG_HEIGHT][IMG_WIDTH], unsigned char output[IMG_HEIGHT][IMG_WIDTH]);
void printMatrix(unsigned char matrix[IMG_HEIGHT][IMG_WIDTH]);


#define TIMER_COUNTER_0	 0
int InitializeTimer(u16 DeviceId);
void StartTimer();
u32 StopTimer();
/************************** Variable Definitions *****************************/

XUartPs Uart_Ps;		/* The instance of the UART Driver */
XTmrCtr TimerInstance;


int main(void)
{

    //unsigned char input_image[IMG_HEIGHT][IMG_WIDTH];
    unsigned char output_image[IMG_HEIGHT][IMG_WIDTH];

    unsigned char input_image[IMG_HEIGHT][IMG_WIDTH] = {
    { 10, 10, 10, 10, 10 },
    { 10, 50, 50, 50, 10 },
    { 10, 50, 100, 50, 10 },
    { 10, 50, 50, 50, 10 },
    { 10, 10, 10, 10, 10 }
    };

    // Check UART
    int Status;
	#ifndef SDT
		Status = InitializeUART(UART_DEVICE_ID);
	#else
		Status = InitializeUART(XUARTPS_BASEADDRESS);
	#endif
    if (Status != XST_SUCCESS) {
        xil_printf("UART Initialization Failed\r\n");
        return XST_FAILURE;
    }
    else{
    	xil_printf("Successfully Initialised UART \r\n");
    }

    // Check timer
    InitializeTimer(TMRCTR_DEVICE_ID);

	// Receive MATRIX
    xil_printf("Receiving Image...\r\n");
    //readImage(input_image);
    xil_printf("Received Image.\r\n");



    // MATRIX Calculation
    StartTimer();
    applySobelFilter(input_image, output_image);
    u32 elapsedTime = StopTimer();
    xil_printf("Finished edge detection.\r\n");



    // Send result
    printMatrix(output_image);
    //writeImage(output_image);
    xil_printf("Time taken for matrix multiplication: %u clock cycles\n", elapsedTime);

    return 0;
}




//InitializeUART Function
#ifndef SDT
int InitializeUART(u16 DeviceId)
#else
int InitializeUART(UINTPTR BaseAddress)
#endif
{
	int Status;
	XUartPs_Config *Config;

	/*
	 * Initialize the UART driver so that it's ready to use
	 * Look up the configuration in the config table and then initialize it.
	 */
	#ifndef SDT
		Config = XUartPs_LookupConfig(DeviceId);
	#else
		Config = XUartPs_LookupConfig(BaseAddress);
	#endif

	if (NULL == Config) {
		return XST_FAILURE;
	}

	Status = XUartPs_CfgInitialize(&Uart_Ps, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	XUartPs_SetBaudRate(&Uart_Ps, 115200);
    return XST_SUCCESS;
}


void applySobelFilter(unsigned char input[IMG_HEIGHT][IMG_WIDTH], unsigned char output[IMG_HEIGHT][IMG_WIDTH]) {
    for (int i = 1; i < IMG_HEIGHT - 1; i++) {
        for (int j = 1; j < IMG_WIDTH - 1; j++) {
            int gx = 0, gy = 0;
            for (int x = -1; x <= 1; x++) {
                for (int y = -1; y <= 1; y++) {
                    gx += input[i + x][j + y] * Gx[x + 1][y + 1];
                    gy += input[i + x][j + y] * Gy[x + 1][y + 1];
                }
            }
            int magnitude = abs(gx) + abs(gy);
            output[i][j] = (magnitude > 255) ? 255 : magnitude; // Cap at 255
        }
    }
}


void printMatrix(unsigned char matrix[IMG_HEIGHT][IMG_WIDTH]) {
    for (int i = 0; i < IMG_HEIGHT; i++) {
        for (int j = 0; j < IMG_WIDTH; j++) {
            printf("%3d ", matrix[i][j]);
        }
        printf("\n");
    }
}



void readImage(unsigned char img[IMG_HEIGHT][IMG_WIDTH]) {
    char buffer[1024];
    for (int i = 0; i < IMG_HEIGHT; i++) {
        for (int j = 0; j < IMG_WIDTH; j++) {
            fgets(buffer, sizeof(buffer), stdin); // Simulating UART read
            sscanf(buffer, "%hhu", &img[i][j]);
        }
    }
}

void writeImage(unsigned char img[IMG_HEIGHT][IMG_WIDTH]) {
    char buffer[1024];
    for (int i = 0; i < IMG_HEIGHT; i++) {
        for (int j = 0; j < IMG_WIDTH; j++) {
            sprintf(buffer, "%hhu\n", img[i][j]);
            fputs(buffer, stdout); // Simulating UART send
        }
    }
}

//Timer
int InitializeTimer(u16 DeviceId) {
    int Status;
    Status = XTmrCtr_Initialize(&TimerInstance, DeviceId);
    if (Status != XST_SUCCESS) {
        xil_printf("Timer initialization failed\n");
        return XST_FAILURE;
    }
    XTmrCtr_SetOptions(&TimerInstance, TIMER_COUNTER_0, XTC_AUTO_RELOAD_OPTION);
    return XST_SUCCESS;
}

void StartTimer() {
    XTmrCtr_Reset(&TimerInstance, TIMER_COUNTER_0);
    XTmrCtr_Start(&TimerInstance, TIMER_COUNTER_0);
}

u32 StopTimer() {
    XTmrCtr_Stop(&TimerInstance, TIMER_COUNTER_0);
    return XTmrCtr_GetValue(&TimerInstance, TIMER_COUNTER_0);
}
